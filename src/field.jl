export create_field_array, field_arr2vec, isfield_ortho_shape


# About the order of indices of fKd:
#
# Like paramKd in assignment.jl, we index fKd as fKd[i,j,k,w], where (i,j,k) are positional
# indices and w is the Cartesian component index.
#
# The reason for this choice is the same as paramKd.  For example, in assigning source
# values to jKd (an array of current density), we usually fix a component first and then
# assign the same value to a range of (i,j,k).  This can be more efficiently done with
# jKd[i,j,k,w], because a contiguous range of (i,j,k) actually corresponds to a contiguous
# memory block.
#
# I think I will need to index the E- and H-fields the same way for matrix-free operations.
# When we perform curl operation on these field arrays, we implement the ∂/∂w operation as
# fixing the component to differentiate first and then perform the differentiation.
# Therefore, again the E[i,j,k,w] indexing scheme results in an operation on a more
# contiguous block in memory space.

create_field_array(N::AbsVecInteger; ncmp::Int=3) = create_field_array(SInt{length(N)}(N), ncmp=ncmp)
create_field_array(N::SInt; ncmp::Int=3) = zeros(CFloat, N.data..., ncmp)


# Create a vector view of the field array.
#
# Note that reshape(fKd, :) creates a vector that shares the memory with fKd, i.e., if the
# entries of the resulting vector change, the corresponding entries of fKd change as well.
# Similarly, PermutedDimsArray(fKd, ...) creates a dimension-permuted array that shares the
# memory with fKd.  On the other hand, a related function permutedims(fKd, ...) creates a
# dimension-permuted array on a new memory space, so shouldn't be used.
field_arr2vec(fKd::AbsArrNumber{K₊₁};  # field array; K₊₁ = K+1, where K is space dimension and 1 is dimension for Cartesian components
              order_cmpfirst::Bool=true
              ) where {K₊₁} =
    order_cmpfirst ? reshape(PermutedDimsArray(fKd, (K₊₁, ntuple(identity,Val(K₊₁-1))...)), :) : reshape(fKd,:)


# Determine if the shape and field subspaces are orthogonal.  Used in smoothing.jl and
# source/*.jl.  For example, smooth_param!() uses a more efficient version of Kottke's
# subpixel smoothing algorithm if the two subspaces are orthogonal, because then the field
# is always tangential to the surface.
#
# (Meanwhile, Kottke's original, unsimplified  algorithm, which decomposes the field into
# the tangential and normal components to the shape surface, is used when the shape and
# field subspaces coincide, because for such decomposition the inner product between the
# field and the surface normal needs to be performed, and the inner product is defined only
# when the two vectors are in the same vector space.  Note that K = Kf does not imply the
# coincidence of the two subspaces; e.g., (K,Kf) = (1,1) for TEM).
#
# The users can always pass the argument isfield˔shp::Bool to indicate this orthogonality,
# but it is cumbersome for the users to determine the orthogonality for all different cases.
# It turns out that in most relevant cases, the orthogonality can be identified by a simple
# analysis of the dimensions of the shape and field subspaces without the users' explicit
# intervention.  The result, which is generated by the following function, is used as the
# default value of the argument isfield˔shp in smooth_param!(); again, the users can always
# override the default value when their problems are not one of the most relevant cases
# handled by this function.
#
# Here is how the orthogonality is determined.  The shape and field subspaces are defined as
# the subspaces of the 3D space where the shapes and fields lie.  In standard 3D problems,
# both subspaces are 3D.  However there are other cases as well: for example, in 2D TM
# problems, the shapes are on the xy-plane (2D space), but the E-fields are along the z-
# direction (1D space).
#
# For the shape and field subspace dimensions K and Kf, orthogonal subspaces can occur only
# when K + Kf ≤ 3, because if two subspaces are orthogonal to each other and K + Kf > 3, we
# can choose 4 or more linearly independent vectors in the direct sum of the two subspaces,
# which is impossible as the direct sum should still be a subspace of the 3D space.
#
# Considering this constraint, there are only a few combinations of K and Kf that allow (but
# not necessarily imply) orthogonal subspaces: (K,Kf) = (2,1), (1,1), (1,2).
# - (K,Kf) = (2,1).  Example cases are 2D TE or TM problems.  The shape subspace is the 2D
# xy- plane, but the magnetic (electric) field subspace in TE (TM) problems is the 1D z-axis.
# - (K,Kf) = (1,1).  Example cases are 1D TEM problems with isotropic materials.  The shape
# subspace is the 1D z-axis, but the E- and H-field spaces are the 1D x- and y-axes.
# - (K,Kf) = (1,2).  Example cases are 1D TEM problems with anisotropic materials.
#
# For each of these combinations of K and Kf, there could be cases other than TE, TM, or TEM.
# However, any problems can be formulated as 3D problems by imposing periodic boundary
# conditions on the axes along which the problems are uniform.  Therefore, the consideration
# of non-3D cases (with K ≠ 3 or Kf ≠ 3) becomes meaningful only when special equations with
# reduced number of DOFs, like the TE, TM, TEM equations, can be formulated for the problems.
# In such meaningful cases, we find that the two subspaces are always orthogonal if K ≠ Kf
# (i.e., when (K,Kf) = (2,1) or (1,2) above).
#
# For the remaining cases of K = Kf, we know K + Kf = 2K should be ≤ 3 for the two subspaces
# to be orthogonal.  Therefore, we conclude that K = Kf = 1 is the only combination that
# allows (but not necessarily implies) orthogonal subspaces while K = Kf.  Now, for K = Kf =
# 1, the two subspaces should be orthogonal to describe relevant problems; otherwise the two
# subspaces must coincide and therefore the field direction and the propagation direciton
# should become perfectly parallel, which is impossible.
#
# In summary, we showed that (K,Kf) = (2,1), (2,1), and (1,1) are the only combinations that
# allow ortohgonal shape and field subspaces, and then further showed that they indeed imply
# orthogonality in relevant cases.  Cases with nonortohgonal subspaces could exist for these
# combinations, but those cases do not produce special equations with reduced number of DOFs
# and therefore are less important.  For those minor cases, the users should override the
# default value of isfield˔shp.
isfield_ortho_shape(Kf, K) = Kf≠K || Kf==1
